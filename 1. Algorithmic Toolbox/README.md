# **Algorithmic Toolbox**
- **T(n)** denotes the number of *lines of code* executed

## **Fibonacci Numbers**
[Visualization](https://www.cs.usfca.edu/~galles/visualization/DPFib.html)

### **Naive approach:** 
![alt_text](./images/fib_nums.JPG 'image')
![alt_text](./images/fib_nums2.JPG 'image')
![alt_text](./images/fib_nums3.JPG 'image')


- Reasoning for it being so inefficient
    - Calculations are being duplicated unnecessarily throughout the recursion process
    
![alt_text](./images/fib_nums4.JPG 'image')


### **Efficient Algorithm**
![alt_text](./images/fib_nums5.JPG 'image')

<br>
<hr>
<br>

## **Greatest Common Divisor**

### **Naive approach**
![alt_text](./images/gcd.JPG 'image')

### **Efficient Algorithm**
![alt_text](./images/gcd2.JPG 'image')
![alt_text](./images/gcd3.JPG 'image')
![alt_text](./images/gcd4.JPG 'image')
![alt_text](./images/gcd5.JPG 'image')
![alt_text](./images/gcd6.JPG 'image')

<br>
<hr>
<br>

## **Computing Runtimes**
- Flaws in the "counting lines" approach is that not every line is equivalent in execution time.
- Different factors for runtime:
    - Speed of the computer, the system architecture, the compiler being used, memory hierarchy

<br>
<hr>
<br>

## **Asymptotic Notation**
[Helpful link](https://www.khanacademy.org/computing/computer-science/algorithms/asymptotic-notation/a/asymptotic-notation)
- How does runtime **scale** with **input size**

![alt_text](./images/asymptotic.JPG 'image')
![alt_text](./images/asymptotic2.JPG 'image')

<br>
<hr>
<br>

## **Big-O Notation**
![alt_text](./images/o_rules.JPG 'image')
![alt_text](./images/others.JPG 'image')
![alt_text](./images/others2.JPG 'image')